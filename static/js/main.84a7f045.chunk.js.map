{"version":3,"sources":["TTTController.js","TTTSquare.js","TTTGrid.js","TTTMenu.js","App.js","index.js"],"names":["TTTController","corners","rows","moveCount","squares","this","center","firstMove","nextMove","indices","forEach","char","index","push","random","Math","floor","length","availableCorner","defenseIndex","i","XCount","OCount","emptyCount","emptyIndex","defaultMove","availableCorners","filter","row","map","TTTSquare","classList","props","isWinningSquare","className","join","data-index","onClick","onSquareClick","Component","TTTGrid","e","target","dataset","bind","winningRow","clickable","indexOf","key","TTTMenu","onResetClick","data-size","onResizeClick","App","defaultState","isGridFilled","isUsersTurn","Array","fill","state","size","controller","emptySquareCount","getWinningRow","setState","appMoves","slice","newIndex","move","setTimeout","preventDefault","userMoves","resetGame","resizeGame","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.84a7f045.chunk.js","sourcesContent":["class TTTController {\n  // each value represents an index of of TTT square\n  corners = [0, 2, 6, 8];\n  rows = [\n    [0, 1, 2],\n    [0, 3, 6],\n    [0, 4, 8],\n    [1, 4, 7],\n    [2, 4, 6],\n    [2, 5, 8],\n    [3, 4, 5],\n    [6, 7, 8]\n  ];\n\n  move(moveCount, squares) {\n    this.squares = squares;\n    this.center  = squares[4];\n    return (moveCount === 1) ? this.firstMove() : this.nextMove();\n  }\n  defaultMove() {\n    const indices = [];\n    this.squares.forEach( (char, index) => {\n      if (char === '') { indices.push(index) }\n    });\n    const random = Math.floor( Math.random() * indices.length );\n    return indices[random];\n  }\n  firstMove() {\n    return (this.center === '') ? 4 : this.availableCorner();\n  }\n  nextMove() {\n    let defenseIndex = null;\n    for (let i = 0; i < this.rows.length; i++) {\n      let XCount = 0, OCount = 0, emptyCount = 0, emptyIndex = null;\n      this.rows[i].forEach( index => {\n        if (this.squares[index] === 'X') { XCount++; }\n        if (this.squares[index] === 'O') { OCount++; }\n        if (this.squares[index] === '') { emptyCount++; emptyIndex = index; }\n      })\n      /* go on offensive immediately if there is an opportunity */\n      if (OCount === 2 && emptyCount === 1) {\n        return emptyIndex;\n      }\n      /* if app needs to make a defensive move, wait for the whole loop to see if there's also an opening for an attack */\n      else if (XCount === 2 && emptyCount === 1) {\n        defenseIndex = emptyIndex;\n      }\n    }\n    return (defenseIndex) ? defenseIndex : this.defaultMove();\n  }\n  availableCorner() {\n    const availableCorners = this.corners.filter( index => this.squares[index] === '' );\n    const random = Math.floor( Math.random() * availableCorners.length );\n    return this.corners[random];\n  }\n\n  getWinningRow(squares) {\n    for (let i = 0, row; i < this.rows.length; i++) {\n      row = this.rows[i].map( index => squares[index] );\n      if (row[0] !== '' && row[0] === row[1] && row[1] === row[2] ) {\n        return this.rows[i];\n      }\n    }\n    return null;\n  }\n\n}\n\nexport default TTTController;\n","import React, { Component } from 'react';\n\nclass TTTSquare extends Component {\n  render() {\n    const classList = ['TTT-box'];\n    if (this.props.isWinningSquare) {\n      classList.push(`TTT-winning-square-${this.props.char}`);\n    }\n    return (\n      <div className={classList.join(' ')} data-index={this.props.index} onClick={this.props.onSquareClick}>\n        <span className=\"TTT-char\">{this.props.char}</span>\n       </div>\n     );\n  }\n}\n\nexport default TTTSquare;\n","import React, { Component } from 'react';\nimport TTTSquare from './TTTSquare';\n\nclass TTTGrid extends Component {\n  constructor(props) {\n    super(props);\n  }\n  onSquareClick(e) {\n    this.props.onSquareClick(e.target.dataset.index);\n  }\n  render() {\n    const squares = [],\n          classList = ['TTT-grid'],\n          onSquareClick = this.onSquareClick.bind(this),\n          winningRow = this.props.winningRow || [];\n       if (!this.props.clickable) { classList.push('disabled'); }\n    this.props.squares.forEach( (char, index) => {\n      squares.push(<TTTSquare\n        char={char}\n        isWinningSquare={ winningRow.indexOf(index) !== -1 }\n        onSquareClick={onSquareClick}\n        key={index}\n        index={index} />);\n    });\n    return (\n      <div className={classList.join(' ')}>{squares}</div>\n    );\n  }\n}\n\nexport default TTTGrid;\n","import React, { Component } from 'react';\n\nclass TTTMenu extends Component {\n  render() {\n    return (\n      <section className=\"TTT-menu\">\n        <button className=\"TTT-reset\" onClick={this.props.onResetClick}>Reset Game</button>\n        <div className=\"TTT-resize-container\">\n          <button className=\"TTT-resize\" data-size=\"sm\" onClick={this.props.onResizeClick}>Small</button> /\n          <button className=\"TTT-resize\" data-size=\"md\" onClick={this.props.onResizeClick}>Medium</button> /\n          <button className=\"TTT-resize\" data-size=\"lg\" onClick={this.props.onResizeClick}>Large</button>\n        </div>\n      </section>\n    );\n  }\n}\n\nexport default TTTMenu;\n","import React, { Component } from 'react';\nimport TTTController from './TTTController';\nimport TTTGrid from './TTTGrid';\nimport TTTMenu from './TTTMenu';\n\nclass App extends Component {\n  defaultState = {\n    isGridFilled: false,\n    isUsersTurn: true,\n    moveCount: 0,\n    squares: Array(9).fill(''),\n    winningRow: null\n  };\n  state = {...this.defaultState, size: 'md' };\n  controller = new TTTController();\n\n  componentDidUpdate() {\n    // don't execute if there is a winning row or if grid is filled\n    if (!this.state.winningRow && !this.state.isGridFilled) {\n      let winningRow, emptySquareCount;\n      // starting with 3rd set of moves, check to see if winning row\n      if (this.state.moveCount >= 3) {\n        winningRow = this.controller.getWinningRow(this.state.squares);\n        if (winningRow) { this.setState({ winningRow }) };\n      }\n      // starting with user's 5th move, check to see if grid is filled\n      if (this.state.moveCount === 5) {\n        emptySquareCount = this.state.squares.filter( char => char === '' ).length;\n        if (emptySquareCount === 0) { this.setState({ isGridFilled: true }) }\n      }\n      // only if it's the app's turn, and grid isn't filled and there isn't a winning row, should app move\n      if (!this.state.isUsersTurn && !winningRow && emptySquareCount !== 0) {\n        this.appMoves();\n      }\n    }\n  }\n  appMoves() {\n    const moveCount = this.state.moveCount;\n    const squares   = this.state.squares.slice();\n    const newIndex = this.controller.move(moveCount, squares);\n    squares[newIndex] = 'O';\n    setTimeout( () => this.setState({ squares, isUsersTurn: true }), 500);\n  }\n  userMoves(index) {\n    if (this.state.squares[index] === '') {\n      const moveCount = this.state.moveCount + 1;\n      const squares   = this.state.squares.slice();\n      squares[index]  = 'X';\n      this.setState({ moveCount, squares, isUsersTurn: false });\n    }\n  }\n  resetGame(e) {\n    e.preventDefault();\n    this.setState(this.defaultState);\n  }\n  resizeGame(e) {\n    e.preventDefault();\n    const size = e.target.dataset.size;\n    this.setState({ size });\n  }\n  render() {\n    return (\n      <main className={this.state.size}>\n        <TTTGrid\n          clickable={this.state.isUsersTurn && !this.state.winningRow && !this.state.isGridFilled}\n          squares={this.state.squares}\n          onSquareClick={this.userMoves.bind(this)}\n          winningRow={this.state.winningRow} />\n        <TTTMenu\n          onResetClick={this.resetGame.bind(this)}\n          onResizeClick={this.resizeGame.bind(this)} />\n      </main>\n    )\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}