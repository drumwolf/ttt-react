{"version":3,"sources":["TTTController.js","TTTSquare.js","TTTGrid.js","TTTMenu.js","App.js","index.js"],"names":["TTTController","corners","rows","squares","this","moveCount","center","firstMove","nextMove","cornerMoves","filter","index","random","Math","floor","length","indices","forEach","char","push","cornerMove","defenseIndex","i","XCount","OCount","emptyCount","emptyIndex","defaultMove","row","map","TTTSquare","classList","props","isWinningSquare","className","join","data-index","onClick","onSquareClick","Component","TTTGrid","e","target","dataset","bind","winningRow","clickable","indexOf","key","TTTMenu","onResetClick","data-size","onResizeClick","App","defaultState","isGridFilled","isUsersTurn","Array","fill","state","size","controller","emptySquareCount","setSquares","getWinningRow","setState","appMoves","slice","newIndex","getMove","setTimeout","preventDefault","userMoves","resetGame","resizeGame","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.dc3c85fc.chunk.js","sourcesContent":["class TTTController {\n  // each value represents an index of of TTT square\n  corners = [0, 2, 6, 8];\n  rows = [\n    [0, 1, 2],\n    [0, 3, 6],\n    [0, 4, 8],\n    [1, 4, 7],\n    [2, 4, 6],\n    [2, 5, 8],\n    [3, 4, 5],\n    [6, 7, 8]\n  ];\n  squares = [];\n\n  /*** 'squares' will show what values 'X', 'O' or '' are in which squares ***/\n  setSquares(squares) {\n    this.squares = squares;\n  }\n\n  /*** determine which square the app will select, and return the square's index ***/\n  getMove(moveCount) {\n    this.center  = this.squares[4];\n    return (moveCount === 1) ? this.firstMove() : this.nextMove();\n  }\n  // second-level auxiliary methods to be called (directly or not) by 'getMove()'\n  cornerMove() {\n    const cornerMoves = this.corners.filter( index => this.squares[index] === '' );\n    const random = Math.floor( Math.random() * cornerMoves.length );\n    return this.corners[random];\n  }\n  defaultMove() {\n    const indices = [];\n    this.squares.forEach( (char, index) => {\n      if (char === '') { indices.push(index) }\n    });\n    const random = Math.floor( Math.random() * indices.length );\n    return indices[random];\n  }\n  firstMove() {\n    return (this.center === '') ? 4 : this.cornerMove();\n  }\n  nextMove() {\n    let defenseIndex = null;\n    for (let i = 0; i < this.rows.length; i++) {\n      let XCount = 0, OCount = 0, emptyCount = 0, emptyIndex = null;\n      this.rows[i].forEach( index => {\n        if (this.squares[index] === 'X') { XCount++; }\n        if (this.squares[index] === 'O') { OCount++; }\n        if (this.squares[index] === '') { emptyCount++; emptyIndex = index; }\n      })\n      /* go on offensive immediately if there is an opportunity */\n      if (OCount === 2 && emptyCount === 1) {\n        return emptyIndex;\n      }\n      /* if app needs to make a defensive move, wait for the whole loop to see if there's also an opening for an attack */\n      else if (XCount === 2 && emptyCount === 1) {\n        defenseIndex = emptyIndex;\n      }\n    }\n    return (defenseIndex) ? defenseIndex : this.defaultMove();\n  }\n\n  /*** determine if there is a winning row, and if so, return an array of its indices ***/\n  getWinningRow(squares) {\n    for (let i = 0, row; i < this.rows.length; i++) {\n      row = this.rows[i].map( index => this.squares[index] );\n      if (row[0] !== '' && row[0] === row[1] && row[1] === row[2] ) {\n        return this.rows[i];\n      }\n    }\n    return null;\n  }\n\n}\n\nexport default TTTController;\n","import React, { Component } from 'react';\n\nclass TTTSquare extends Component {\n  render() {\n    const classList = ['TTT-box'];\n    if (this.props.isWinningSquare) {\n      classList.push(`TTT-winning-square-${this.props.char}`);\n    }\n    return (\n      <div className={classList.join(' ')} data-index={this.props.index} onClick={this.props.onSquareClick}>\n        <span className=\"TTT-char\">{this.props.char}</span>\n       </div>\n     );\n  }\n}\n\nexport default TTTSquare;\n","import React, { Component } from 'react';\nimport TTTSquare from './TTTSquare';\n\nclass TTTGrid extends Component {\n  constructor(props) {\n    super(props);\n  }\n  onSquareClick(e) {\n    this.props.onSquareClick(e.target.dataset.index);\n  }\n  render() {\n    const squares = [],\n          classList = ['TTT-grid'],\n          onSquareClick = this.onSquareClick.bind(this),\n          winningRow = this.props.winningRow || [];\n       if (!this.props.clickable) { classList.push('disabled'); }\n    this.props.squares.forEach( (char, index) => {\n      squares.push(<TTTSquare\n        char={char}\n        isWinningSquare={ winningRow.indexOf(index) !== -1 }\n        onSquareClick={onSquareClick}\n        key={index}\n        index={index} />);\n    });\n    return (\n      <div className={classList.join(' ')}>{squares}</div>\n    );\n  }\n}\n\nexport default TTTGrid;\n","import React, { Component } from 'react';\n\nclass TTTMenu extends Component {\n  render() {\n    return (\n      <section className=\"TTT-menu\">\n        <button className=\"TTT-reset\" onClick={this.props.onResetClick}>Reset Game</button>\n        <div className=\"TTT-resize-container\">\n          <button className=\"TTT-resize\" data-size=\"sm\" onClick={this.props.onResizeClick}>Small</button> /\n          <button className=\"TTT-resize\" data-size=\"md\" onClick={this.props.onResizeClick}>Medium</button> /\n          <button className=\"TTT-resize\" data-size=\"lg\" onClick={this.props.onResizeClick}>Large</button>\n        </div>\n      </section>\n    );\n  }\n}\n\nexport default TTTMenu;\n","import React, { Component } from 'react';\nimport TTTController from './TTTController';\nimport TTTGrid from './TTTGrid';\nimport TTTMenu from './TTTMenu';\n\nclass App extends Component {\n  defaultState = {\n    isGridFilled: false,\n    isUsersTurn: true,\n    moveCount: 0,\n    squares: Array(9).fill(''),\n    winningRow: null\n  };\n  state = {...this.defaultState, size: 'md' };\n  controller = new TTTController();\n\n  componentDidUpdate() {\n    this.controller.setSquares(this.state.squares);\n    // don't execute if there is a winning row or if grid is filled\n    if (!this.state.winningRow && !this.state.isGridFilled) {\n      let winningRow, emptySquareCount;\n      // starting with 3rd set of moves, check to see if winning row\n      if (this.state.moveCount >= 3) {\n        winningRow = this.controller.getWinningRow();\n        if (winningRow) { this.setState({ winningRow }) };\n      }\n      // starting with user's 5th move, check to see if grid is filled\n      if (this.state.moveCount === 5) {\n        emptySquareCount = this.state.squares.filter( char => char === '' ).length;\n        if (emptySquareCount === 0) { this.setState({ isGridFilled: true }) }\n      }\n      // only if it's the app's turn, and grid isn't filled and there isn't a winning row, should app move\n      if (!this.state.isUsersTurn && !winningRow && emptySquareCount !== 0) {\n        this.appMoves();\n      }\n    }\n  }\n  appMoves() {\n    const moveCount = this.state.moveCount;\n    const squares   = this.state.squares.slice();\n    const newIndex  = this.controller.getMove(moveCount);\n    squares[newIndex] = 'O';\n    setTimeout( () => this.setState({ squares, isUsersTurn: true }), 500);\n  }\n  userMoves(index) {\n    if (this.state.squares[index] === '') {\n      const moveCount = this.state.moveCount + 1;\n      const squares   = this.state.squares.slice();\n      squares[index]  = 'X';\n      this.setState({ moveCount, squares, isUsersTurn: false });\n    }\n  }\n  resetGame(e) {\n    e.preventDefault();\n    this.setState(this.defaultState);\n  }\n  resizeGame(e) {\n    e.preventDefault();\n    const size = e.target.dataset.size;\n    this.setState({ size });\n  }\n  render() {\n    return (\n      <main className={this.state.size}>\n        <TTTGrid\n          clickable={this.state.isUsersTurn && !this.state.winningRow && !this.state.isGridFilled}\n          squares={this.state.squares}\n          onSquareClick={this.userMoves.bind(this)}\n          winningRow={this.state.winningRow} />\n        <TTTMenu\n          onResetClick={this.resetGame.bind(this)}\n          onResizeClick={this.resizeGame.bind(this)} />\n      </main>\n    )\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}