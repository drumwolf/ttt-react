{"version":3,"sources":["TTTController.js","TTTSquare.js","TTTGrid.js","TTTMenu.js","App.js","index.js"],"names":["TTTController","corners","rows","squares","this","moveCount","center","firstMove","nextMove","cornerMoves","filter","index","random","Math","floor","length","indices","forEach","char","push","cornerMove","defenseIndex","i","XCount","OCount","emptyCount","emptyIndex","defaultMove","row","map","TTTSquare","classList","props","isWinningSquare","isGameOver","className","join","data-index","onClick","onSquareClick","Component","TTTGrid","e","target","dataset","bind","winningRow","clickable","isGridFilled","indexOf","key","TTTMenu","onResetClick","data-size","onResizeClick","App","defaultState","isUsersTurn","Array","fill","state","size","controller","emptySquareCount","setSquares","getWinningRow","setState","appMoves","slice","newIndex","getMove","setTimeout","preventDefault","userMoves","resetGame","resizeGame","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.159ada50.chunk.js","sourcesContent":["/*\nThis is not a React component.  It is essentially the \"brain\" of the app which will determine the following:\n- what square to pick when it moves\n- whether or not there is a winning row combination\n\nThis class was designed with the following assumptions:\n- user player will move first, app player will move afterwards\n- user will be 'X', app will be 'O'\n\n*/\nclass TTTController {\n  // each value represents an index of of TTT square\n  corners = [0, 2, 6, 8];\n  rows = [\n    [0, 1, 2],\n    [0, 3, 6],\n    [0, 4, 8],\n    [1, 4, 7],\n    [2, 4, 6],\n    [2, 5, 8],\n    [3, 4, 5],\n    [6, 7, 8]\n  ];\n  squares = [];\n\n  /*** 'squares' will show what values 'X', 'O' or '' are in which squares ***/\n  setSquares(squares) {\n    this.squares = squares;\n  }\n\n  /*** determine which square the app will select, and return the square's index ***/\n  getMove(moveCount) {\n    this.center  = this.squares[4];\n    return (moveCount === 1) ? this.firstMove() : this.nextMove();\n  }\n  // second-level auxiliary methods to be called (directly or not) by 'getMove()'\n  cornerMove() {\n    const cornerMoves = this.corners.filter( index => this.squares[index] === '' );\n    const random = Math.floor( Math.random() * cornerMoves.length );\n    return this.corners[random];\n  }\n  defaultMove() {\n    const indices = [];\n    this.squares.forEach( (char, index) => {\n      if (char === '') { indices.push(index) }\n    });\n    const random = Math.floor( Math.random() * indices.length );\n    return indices[random];\n  }\n  firstMove() {\n    return (this.center === '') ? 4 : this.cornerMove();\n  }\n  nextMove() {\n    let defenseIndex = null;\n    for (let i = 0; i < this.rows.length; i++) {\n      let XCount = 0, OCount = 0, emptyCount = 0, emptyIndex = null;\n      this.rows[i].forEach( index => {\n        if (this.squares[index] === 'X') { XCount++; }\n        if (this.squares[index] === 'O') { OCount++; }\n        if (this.squares[index] === '') { emptyCount++; emptyIndex = index; }\n      })\n      /* go on offensive immediately if there is an opportunity */\n      if (OCount === 2 && emptyCount === 1) {\n        return emptyIndex;\n      }\n      /* if app needs to make a defensive move, wait for the whole loop to see if there's also an opening for an attack */\n      else if (XCount === 2 && emptyCount === 1) {\n        defenseIndex = emptyIndex;\n      }\n    }\n    return (defenseIndex) ? defenseIndex : this.defaultMove();\n  }\n\n  /*** determine if there is a winning row, and if so, return an array of its indices ***/\n  getWinningRow(squares) {\n    for (let i = 0, row; i < this.rows.length; i++) {\n      row = this.rows[i].map( index => this.squares[index] );\n      if (row[0] !== '' && row[0] === row[1] && row[1] === row[2] ) {\n        return this.rows[i];\n      }\n    }\n    return null;\n  }\n\n}\n\nexport default TTTController;\n","import React, { Component } from 'react';\n\nclass TTTSquare extends Component {\n  render() {\n    // default class\n    const classList = ['TTT-box'];\n    // implement either 'winning-square' or 'game-over' class selectors (but not both)\n    if (this.props.isWinningSquare) {\n      classList.push(`TTT-winning-square-${this.props.char}`);\n    } else if (this.props.isGameOver) {\n      classList.push('TTT-game-over');\n    }\n    // disable square if it's filled\n    if (this.props.char !== '') {\n      classList.push('disabled');\n    }\n    // final component\n    return (\n      <div className={classList.join(' ')} data-index={this.props.index} onClick={this.props.onSquareClick}>\n        <span className=\"TTT-char\">{this.props.char}</span>\n       </div>\n     );\n  }\n}\n\nexport default TTTSquare;\n","import React, { Component } from 'react';\nimport TTTSquare from './TTTSquare';\n\nclass TTTGrid extends Component {\n  constructor(props) {\n    super(props);\n  }\n  onSquareClick(e) {\n    this.props.onSquareClick(e.target.dataset.index);\n  }\n  render() {\n    // initialize variables\n    const squares = [],\n          classList = ['TTT-grid'],\n          onSquareClick = this.onSquareClick.bind(this),\n          winningRow = this.props.winningRow || [];\n    // css classes where applicable\n    if (!this.props.clickable) { classList.push('disabled'); }\n    // assemble collection of squares\n    this.props.squares.forEach( (char, index) => {\n      squares.push(<TTTSquare\n        char={char}\n        isGameOver={this.props.isGridFilled || winningRow.length === 3}\n        isWinningSquare={ winningRow.indexOf(index) !== -1 }\n        onSquareClick={onSquareClick}\n        key={index}\n        index={index} />);\n    });\n    // final component\n    return (\n      <div className={classList.join(' ')}>{squares}</div>\n    );\n  }\n}\n\nexport default TTTGrid;\n","import React, { Component } from 'react';\n\nclass TTTMenu extends Component {\n  render() {\n    return (\n      <section className=\"TTT-menu\">\n        <button className=\"TTT-reset\" onClick={this.props.onResetClick}>Reset Game</button>\n        <div className=\"TTT-resize-container\">\n          <button className=\"TTT-resize\" data-size=\"sm\" onClick={this.props.onResizeClick}>Small</button> /\n          <button className=\"TTT-resize\" data-size=\"md\" onClick={this.props.onResizeClick}>Medium</button> /\n          <button className=\"TTT-resize\" data-size=\"lg\" onClick={this.props.onResizeClick}>Large</button>\n        </div>\n      </section>\n    );\n  }\n}\n\nexport default TTTMenu;\n","import React, { Component } from 'react';\nimport TTTController from './TTTController';\nimport TTTGrid from './TTTGrid';\nimport TTTMenu from './TTTMenu';\n\nclass App extends Component {\n  defaultState = {\n    isGridFilled: false,\n    isUsersTurn: true,\n    moveCount: 0,\n    squares: Array(9).fill(''),\n    winningRow: null\n  };\n  state = {...this.defaultState, size: 'md' };\n  controller = new TTTController();\n\n  componentDidUpdate() {\n    /*** don't execute if there is a winning row or if grid is filled ***/\n    if (!this.state.winningRow && !this.state.isGridFilled) {\n      let winningRow, emptySquareCount;\n      this.controller.setSquares(this.state.squares);\n      // starting with 3rd set of moves, check to see if winning row\n      if (this.state.moveCount >= 3) {\n        winningRow = this.controller.getWinningRow();\n        if (winningRow) { this.setState({ winningRow }) };\n      }\n      // starting with user's 5th move, check to see if grid is filled\n      if (this.state.moveCount === 5) {\n        emptySquareCount = this.state.squares.filter( char => char === '' ).length;\n        if (emptySquareCount === 0) { this.setState({ isGridFilled: true }) }\n      }\n      // only if it's the app's turn, and grid isn't filled and there isn't a winning row, should app move\n      if (!this.state.isUsersTurn && !winningRow && emptySquareCount !== 0) {\n        this.appMoves();\n      }\n    }\n  }\n  appMoves() {\n    const moveCount = this.state.moveCount;\n    const squares   = this.state.squares.slice();\n    const newIndex  = this.controller.getMove(moveCount);\n    squares[newIndex] = 'O';\n    setTimeout( () => this.setState({ squares, isUsersTurn: true }), 500);\n  }\n  userMoves(index) {\n    if (this.state.squares[index] === '') {\n      const moveCount = this.state.moveCount + 1;\n      const squares   = this.state.squares.slice();\n      squares[index]  = 'X';\n      this.setState({ moveCount, squares, isUsersTurn: false });\n    }\n  }\n  resetGame(e) {\n    e.preventDefault();\n    this.setState(this.defaultState);\n  }\n  resizeGame(e) {\n    e.preventDefault();\n    this.setState({ size: e.target.dataset.size });\n  }\n  render() {\n    return (\n      <main className={this.state.size}>\n        <TTTGrid\n          clickable={this.state.isUsersTurn && !this.state.winningRow && !this.state.isGridFilled}\n          isGridFilled={this.state.isGridFilled}\n          squares={this.state.squares}\n          onSquareClick={this.userMoves.bind(this)}\n          winningRow={this.state.winningRow} />\n        <TTTMenu\n          onResetClick={this.resetGame.bind(this)}\n          onResizeClick={this.resizeGame.bind(this)} />\n      </main>\n    )\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}